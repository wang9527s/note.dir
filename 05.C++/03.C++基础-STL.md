
## 章节目录

[TOC]

---

## 一、概述

&emsp;&emsp;长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。  
&emsp;&emsp;复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。  
&emsp;&emsp;为了建立数据结构和算法的**一套标准**，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。

&emsp;&emsp;STL(Standard Template Library)标准模板库，几乎所有的代码都采用了模板类或者模板函数。在我们c++标准程序库中隶属于STL的占到了80%以上。

&emsp;&emsp;**stl标准库的功能由编译器实现，比如gcc和msvc**

### 1. STL六大组件简介

&emsp;&emsp;STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:**容器**、**算法**、**迭代器**、**仿函数**、**适配器（配接器）**、**空间配置器**。

+ **容器**: 各种数据结构，如```vector、list、deque、set、map```等,用来存放数据，从实现角度来看，STL容器是一种class template。
+ **算法**: 各种常用的算法，如```sort、find、copy、for_each```。从实现的角度来看，STL算法是一种function tempalte。
+ **迭代器**: 扮演了容器与算法之间的胶合剂，迭代器是一种将```* , -> , ++, –```等相关操作符进行重载的class template。  
&emsp;&emsp;所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。  
&emsp;&emsp;原生指针(native pointer)也是一种迭代器。
+ **仿函数**: 行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template
+ **适配器**: 一种用来修饰容器或者仿函数或迭代器接口的东西。
+ **空间配置器**: 负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte。

&emsp;&emsp;STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。

### 2. 三大组件介绍

#### 2.1 容器

&emsp;&emsp;几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。  
&emsp;&emsp;常用的数据结构：**数组**(array) , **链表**(list), tree(**树**)，**栈**(stack), **队列**(queue), **集合**(set),**映射表**(map), 根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。

- 序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。
- 关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器  

#### 2.2 算法

&emsp;&emsp;算法，问题的解法，以有限的步骤，解决逻辑或数学上的问题。

&emsp;&emsp;我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。

算法分为:质变算法和非质变算法。

- 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等
- 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等  

#### 2.3 迭代器

&emsp;&emsp;迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。设计模式中关于iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

## 二、常用容器

### 1. string容器

&emsp;&emsp;C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件```<string>```。  
&emsp;&emsp;在c++中存在一个从```const char *```到```string```的隐式类型转换。对于string类型的字符串，通过```c_str()```才可以转换为```char*``` 。  
&emsp;&emsp;string和c风格字符串对比：

- ```char *```是一个指针，string是一个类。string封装了```char*```，管理这个字符串，是一个```char *```型的容器。
- string封装了很多实用的成员方法，比如find、copy、delete、replace、insert
- string不用考虑内存释放和越界的问题

### 2. vector容器

&emsp;&emsp;vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。

&emsp;&emsp;array是静态空间，一旦配置了就不能改变；如果想改变大小，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。  
&emsp;&emsp;vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间（变为之前的2倍）以容纳新元素。

&emsp;&emsp;vector其实是一个结构体，它的内容其实是3个指针构成的。第一个指针是首元素的地址，第二个指针是最后一个元素的地址 + 1(即最后一个元素的最后一个字节的地址+1)，第三指针是vector::capacity的最后一个元素的地址 + 1。假如vector内容为空，则三个指针的内容均为0（nullptr）。

&emsp;&emsp;**注意**，所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，**一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了**。

+ 实际空间大小和已使用大小

```cpp
capacity();                // 内存中实际分配的空间的大小
reserve(int len);        // 容器预留len个元素长度，预留位置不初始化，元素不可访问。
//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num);
```

+ 巧用swap，收缩内存空间

```auto
    vector<int>(v).swap(v);
```

&emsp;&emsp;首先```vector<int>(v)```是利用了v初始化了一个匿名对象，这个匿名对象会按照容器v中实际元素个数去初始化，及容量以及大小均为3  
&emsp;&emsp;而后匿名对象再调用swap函数实现与容器v的互换，原本的容器v就会指向这个容量大小均为3的内存块  
&emsp;&emsp;匿名对象现在就指向了容量较大的内存块，由于匿名对象的特性，该行结束后，系统会自动回收匿名对象占用的内存，从而实现了内存收缩

### 3. deque容器

&emsp;&emsp;和vector在内存中是一段连续的空间不同，deque是分段连续内存空间。所以deque没有容量的概念。
&emsp;&emsp;deque可以在头尾两端分别做元素的插入和删除操作。

+ deque容器实现原理

&emsp;&emsp;deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。
&emsp;&emsp;deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。所以和vector相比，deque的效率比较低。
&emsp;&emsp;因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque。

### 4. stack/queue

&emsp;&emsp;stack和queue一样，没有对应的内存结果，实际上是对deque的封装。

&emsp;&emsp;stack是一种先进后出(First In Last Out,FILO)的数据结构。允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为，也不提供迭代器。

&emsp;&emsp;queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。和stack一样，queue不提供遍历功能，也不提供迭代器。

### 5. list容器

&emsp;&emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。和vector相比，list便于数据的插入和删除。list容器不仅是一个双向链表，而且还是一个循环的双向链表。

+ list容器的迭代器

&emsp;&emsp;list容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。迭代器必须能够具备前移、后移的能力，所以list容器提供的是```Bidirectional Iterators```。  
&emsp;&emsp;list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。  

### 5. set/multiset容器

&emsp;&emsp;所有元素都会根据元素的键值自动被排序，不允许两个元素有相同的键值。不可以通过set的迭代器改变set元素的值。

&emsp;&emsp;set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。

&emsp;&emsp;set可以自定义排序规则，```set<Person, MyCompare03> s;```

&emsp;&emsp;multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。  
&emsp;&emsp;set和multiset的底层实现是红黑树.

### 6.对组(pair)

&emsp;&emsp;对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。  
&emsp;&emsp;类模板：`template <class T1, class T2> struct pair.`

### 6. map/multimap容器

&emsp;&emsp;map<key,value>，也会根据key值自动排序；可以将键值对视为一个pair。

&emsp;&emsp;我们不可以通过map的迭代器改变map的key值, 因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织；可以对value进行修改。

&emsp;&emsp;map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。

&emsp;&emsp;multimap和map的操作类似，唯一区别multimap键值可重复。  
&emsp;&emsp;map和multimap都是以红黑树为底层实现机制。

## 三、STL的总结

### 1. 查找元素的速度

&emsp;&emsp;set和map是二叉树结构，利于查找；vector和deque的查找速度比较慢，list最慢

### 2. 适用场景

+ array：固定大小数组。支持快速随机访问，不能添加或删除元素
+ vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。**适合不会修改的数据，比如历史记录**
+ deque：双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。**比如排队购票，queue和stack本质上和- deque是一个东西**
+ list：双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。**比如公交车乘客的存储，随时可能有（不定位置的）乘客下车**
+ forward_list：单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。
+ string：与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。
+ set：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。（multiset更加适，支出重复数据）
+ map：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。

### 3. vector与deque的比较

a) vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。
b) 如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。
c) deque支持头部的快速插入与快速移除，这是deque的优点。

### 4. 对比表格

| 容器 | 底层数据结构 | 时间复杂度 | 有无序 | 可不可重复 | 其他 |
| --- | --- | --- | --- | --- | --- |
| array | 数组 | 随机读改O(1) | 无序 | 可重复 | 支持随机访问 |
| vector | 数组 | 随机读改、尾部插入、尾部删除O(1),头部插入、头部删除O(n) | 无序 | 可重复 | 支持随机访问 |
| deque | 双端队列 | 头尾插入、头尾删除 O(1) | 无序 | 可重复 | 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 |
| forward_list | 单向链表 | 插入、删除 O(1) | 无序 | 可重复 | 不支持随机访问 |  |
| list | 双向链表 | 插入、删除 O(1) | 无序 | 可重复 | 不支持随机访问 |
| stack | deque / list | 顶部插入、顶部删除 O(1) | 无序 | 可重复 | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
| queue | deque / list | 尾部插入、头部删除 O(1) | 无序 | 可重复 | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
| priority\_queue | vector + max-heap | 插入、删除 O(log2n) | 有序 | 可重复 | vector容器+heap处理规则 |
| set | 红黑树 | 插入、删除、查找 O(log2n) | 有序 | 不可重复 |  |
| multiset | 红黑树 | 插入、删除、查找 O(log2n) | 有序 | 可重复 |  |
| map | 红黑树 | 插入、删除、查找 O(log2n) | 有序 | 不可重复 |  |
| multimap | 红黑树 | 插入、删除、查找 O(log2n) | 有序 | 可重复 |  |
| unordered_set | 哈希表 | 插入、删除、查找 O(1) 最差 O(n) | 无序 | 不可重复 |  |
| unordered_multiset | 哈希表 | 插入、删除、查找 O(1) 最差 O(n) | 无序 | 可重复 |  |
| unordered_map | 哈希表 | 插入、删除、查找 O(1) 最差 O(n) | 无序 | 不可重复 |  |
| unordered_multimap | 哈希表 | 插入、删除、查找 O(1) 最差 O(n) | 无序 | 可重复 |  |
