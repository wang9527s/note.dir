
## 章节目录

[TOC]

---

C++笔记，部分内容来自[github分享](https://github.com/0voice/cpp_new_features)

## 1、内存分区模型

### 1.1 C++程序在执行时，将内存大方向划分为4个区域

+ 代码区：存放函数体的二进制代码，由操作系统进行管理的

&emsp;&emsp;存放 CPU 执行的机器指令  
&emsp;&emsp;代码区是**共享的**，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可  
&emsp;&emsp;代码区是**只读的**，使其只读的原因是防止程序意外地修改了它的指令

+ 全局区

&emsp;&emsp;**全局变量和静态变量**存放在此  
&emsp;&emsp;全局区还包含了**常量区, 存放 const修饰的全局常量 和 字符串常量**  
&emsp;&emsp;该区域的数据在程序结束后由操作系统释放

+ 栈区：存**放函数的参数、局部变量、局部常量**

&emsp;&emsp;栈空间由操作系统提供，在编译阶段确定入栈和出栈的操作。

+ 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

&emsp;&emsp;用new开辟的对象（手动释放）

### 1.2 堆栈空间的比较

&emsp;&emsp;栈空间是一块连续的区域，是一个严格后进先出的数据结构，有计算机底层的支持，压栈和出栈都有专门的指令和寄存器，效率较高。

&emsp;&emsp;堆空间逻辑上是连续的，物理上不是连续的（多个malloc之间）。malloc/free操作很容易造成堆碎片

### 1.3 线程

&emsp;&emsp;每个线程都有自己独立的、私有的堆栈。所以线程之间共享全局变量、全局常量和字符串常量。

### 1.4 内存管理

&emsp;&emsp;在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。  
&emsp;&emsp;malloc申请n字节的空间，实际申请到的block空间比n大，其中存放了一些控制块。

## 2、基础语法

### 2.1 const 与 指针

+ 常量指针(本质是指针)

&emsp;&emsp;```const int * p1 = &a;```  
&emsp;&emsp;指向常量的指针；  
&emsp;&emsp;const修饰的是指针，可以修改**指针的指向**

+ 指针常量(本质是常量)

&emsp;&emsp;```int * const p=&a;```  
&emsp;&emsp;const修饰的是常量，可以修改**指针指向的值**

### 2.2 指针常量和引用

&emsp;&emsp;引用的本质在c++内部实现是一个指针常量，所以指向不可改  
&emsp;&emsp;编译会将int& ref = a 自动转换为 int* const ref = &a

&emsp;&emsp;常量引用主要用来修饰形参，防止误操作：const int& v

#### 2.2.1 引用的特点

&emsp;&emsp;引用必须初始化  
&emsp;&emsp;引用在初始化后，不可以改变  
&emsp;&emsp;引用可以作为返回值

### 2.3 const 与 #define 的比较

&emsp;&emsp;const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。  

| 宏定义 #define  |  const 常量 |
| ------------ | ------------ |
| 宏定义，相当于字符替换，无数据类型  | 常量数据类型  |
| 预处理器处理，无类型安全检查  |  编译器处理，有类型安全检查 |
| 存储在代码段  | 存储在全局常亮或栈区  |
| 可通过 #undef 取消 | 不可取消  |
| 无法调试| 有些调试工具可以调试const常量 |

### 2.4 static

+ 修饰普通变量

&emsp;&emsp;修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。

+ 修饰普通函数

&emsp;&emsp;**表明函数的作用范围，仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。

+ 修饰成员变量
  
&emsp;&emsp;修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。

+ 修饰成员函数

&emsp;&emsp;修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

## 3、 函数提高

### 3.1 函数占位符

&emsp;&emsp;占位符可以拥有默认参数，如果占位符没有写默认参数，那么调用的时候必须填写。包含占位符的函数声明如下：```void func2(int a,int = 1){}```

### 3.2 函数重载

1) 参数int & a 和参数 const inst & a是不同的；
2) func2(int a, int b = 10)和func2(int a)是相同的，使用func2(0)的时候无法区分想要调用的是第一个还是第二个函数

### 3.3 内联函数

&emsp;&emsp;内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。

&emsp;&emsp;如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

&emsp;&emsp;是否内联是由编译器控制，程序员不可控（只提供建议）

## 4、 对象的初始化和清理

### 4.1 C++中 struct和class唯一的区别就在于 默认的访问权限不同

### 4.2 构造函数

#### 4.2.1 普通构造函数

```cpp
    //2.1  括号法，常用
    Person p1(10);
    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
    //Person p2();

    //2.2 显式法
    Person p2 = Person(10); 
    Person p3 = Person(p2);

    //2.3 隐式转换法
    Person p4 = 10; // Person p4 = Person(10); 
    Person p5 = p4; // Person p5 = Person(p4); 
```

&emsp;&emsp;```Person(参数)```单独写表示生成了一个匿名对象，当前行结束后，该对象立即析构。  
&emsp;&emsp;但是，不能利用拷贝构造函数，初始化一个匿名对象，编译器认为是一个对象声明。例如```Person(p)```，编译器会将括号删除，直接表示为 ```Person p```。  TODO 验证

#### 4.2.2 拷贝构造函数

&emsp;&emsp;拷贝构造函数的定义

```cpp
    Person(const Person& p) {
        age = p.age;
        cout << "拷贝构造函数!" << endl;
    }
```

+ 拷贝构造函数调用时机

&emsp;&emsp;当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数会被调用。

&emsp;&emsp;C++中拷贝构造函数调用时机通常有如下三种情况：

&emsp;&emsp;1) 使用一个已经创建完毕的对象来初始化一个新对象  
&emsp;&emsp;2) 值传递的方式给函数参数传值  
&emsp;&emsp;3) 以值方式返回局部对象

+ 拷贝构造函数和赋值操作符

```cpp
    Person man(100); 
    Person newman(man);     // 调用拷贝构造函数
    Person newman2 = man;   // 拷贝构造
    newman2 = man;          // 调用 = 赋值操作符
```

&emsp;&emsp;**复制构造函数**是去完成对未初始化的存储区的初始化，而**赋值操作符**则是处理一个已经存在的对象。

#### 4.2.3  编译器自动添加的函数

&emsp;&emsp;默认情况下，c++编译器会给一个类添加如下函数：

+ 默认构造函数(无参)
+ 默认析构函数(无参)
+ 默认拷贝构造函数，对属性进行值拷贝
+ 赋值运算符 operator=, 对属性进行值拷贝

&emsp;&emsp;如果用户自定义**有参构造函数**，c++不在提供默认无参构造，但是会提供默认拷贝构造。  
&emsp;&emsp;如果用户**自定义拷贝构造函数**，c++不会再提供**其他构造函数**

#### 4.2.4  构造函数执行顺序

1) 构造的顺序是 ：先调用对象成员的构造，再调用本类构造
2) 析构顺序与构造相反

#### 4.2.5 初始化列表

+ 必须使用参数列表初始化的情况

&emsp;&emsp;const和引用变量必须使用初始化列表进行初始化；  
&emsp;&emsp;没有默认构造函数的类成员，包括基类没有默认构造函数；

&emsp;&emsp;如果在类中声明了成员变量，并且构造函数初始化列表中也初始化了该成员变量，则只执行参数初始化列表中的构造。

#### 4.2.6 静态成员

+ 静态成员变量

&emsp;&emsp;所有对象共享同一份数据  
&emsp;&emsp;在编译阶段分配内存  
&emsp;&emsp;类内声明，类外初始化

+ 静态成员函数

&emsp;&emsp;所有对象共享同一个函数  
&emsp;&emsp;静态成员函数只能访问静态成员变量

### 4.3 C++对象模型和this指针

#### 4.3.1成员变量和成员函数分开存储

&emsp;&emsp;非静态成员变量占对象空间  
&emsp;&emsp;静态成员变量不占对象空间  
&emsp;&emsp;函数也不占对象空间，所有函数共享一个函数实例  
&emsp;&emsp;静态成员函数也不占对象空间  

+ 总结

&emsp;&emsp;类内的成员变量和成员函数分开存储，只有**非静态成员变量**才属于类的对象上  

#### 4.3.2 this指针

&emsp;&emsp;我们知道在C++中成员变量和成员函数是分开存储的。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。

&emsp;&emsp;那么问题是：这一块代码是如何区分那个对象调用自己的呢？

&emsp;&emsp;c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**。

+ this指针的用途：

&emsp;&emsp;当形参和成员变量同名时，可用this指针来区分  
&emsp;&emsp;在类的非静态成员函数中返回对象本身，可使用return *this

#### 4.3.3 空指针访问成员函数

```cpp
Person *p=nullprt;
p->country()        // 如果country方法中没有使用this，函数可以正常运行
```

&emsp;&emsp;在类中使用成员变量和成员函数，可以不加this；编译器在展开时，自动添加this  
&emsp;&emsp;想到了一种写法 ```if (this == nullptr) return;``` **啧啧**

#### 4.3.4 const 修饰成员函数和类

+ 常函数

&emsp;&emsp;成员函数后加const后我们称为这个函数为常函数  
&emsp;&emsp;常函数内不可以修改成员属性  
&emsp;&emsp;成员属性声明时加关键字mutable后，在常函数中依然可以修改

+ 常对象

&emsp;&emsp;声明对象前加const称该对象为常对象  
&emsp;&emsp;常对象只能调用常函数

### 4.4 友元

&emsp;&emsp;友元的目的就是让一个函数或者类，可以访问另一个类中私有成员。友元有3种形式：全局函数做友元、类做友元、成员函数做友元  

&emsp;&emsp;注意: 友元关系不能被继承；友元关系是单向的，不具有交换性；友元关系不具有传递性。

### 4.5 运算符重载

&emsp;&emsp;[运算符重载](./02.C%2B%2B%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.md)

### 4.6 继承

#### 4.6.1 继承和访问权限

&emsp;&emsp;public继承，基类三种访问属性在派生类中分别变成: public, protected, private  
&emsp;&emsp;protected继承，基类三种访问属性在派生类中分别变成: protected, protected, private  
&emsp;&emsp;private继承，基类三种访问属性在派生类中分别变成: private, private, private

&emsp;&emsp;子类继承父类时，也将父类私有变量/方法继承了过来，只是对子类不可见，不可操作。  
&emsp;&emsp;private只有当前类和友元可以访问。  
&emsp;&emsp;子类对象加作用域可以访问到父类同名成员

#### 4.6.2 抽象类和纯虚函数

&emsp;&emsp;纯虚函数，语法：virtual 返回值类型 函数名 （参数列表）= 0  
&emsp;&emsp;抽象类：类中包含的纯虚函数的类叫做抽象类，抽象类不可以实例化。

#### 4.6.3 多态和虚析构函数

+ 分析删除多态对象的内存释放

```cpp
    Animal *animal = new Cat("Tom");
    animal->Speak();

    delete animal
```

&emsp;&emsp;基类指针指向子类对象，一般来说，调用的是基类的方法；但如果基类的方法是虚函数，则调用子类方法。所以在delete基类指针的时候，有如下两种情况：

&emsp;&emsp;1) 如果基类的析构函数**不是虚析构函数**，则调用基类的析构函数  
&emsp;&emsp;2) 如果基类的析构函数**是虚析构函数**，则先调用子类的析构函数，然后调用基类的析构函数。（调用子类析构函数，释放子类new出来的空间）

#### 4.6.4 虚函数表

&emsp;&emsp;如果当前类或者基类中有virtual函数，则实例化的对象中；第一个对象是虚表指针。  
&emsp;&emsp;一个类只有一个虚函数表。在编译时，一个类的虚函数表就确定了，存放在只读数据段中。

+ 普通继承

&emsp;&emsp;子类中与基类虚函数同名的函数，也会自动加上virtual。

&emsp;&emsp;<font color='red'> **虚函数表实现多态的原理：** </font>首先，子类会继承基类的虚函数表（子类和基类的表不是同一个表，虚表指针没有指向同一块空间），如果重写了基类的虚函数会更新虚函数表。如果没有重写任何基类的虚函数，那么子类和基类的虚函数表是内容是一致的。

+ 多继承

&emsp;&emsp;在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。

注意：

+ 1.子类虚函数会覆盖每一个父类的每一个同名虚函数。
+ 2.父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。(不能调用，编译期就已经不存在)
+ 3.父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。

#### 4.6.5 虚继承

```cpp
    class A;
    class B:public A
    class C:public A
    class D:public B,C
```

&emsp;&emsp;如上，菱形继承，D中需要继承2份A的原始变量，会出现错误。虚继承就是为了解决这个问题。

```cpp
    class A;
    class B:virtual public A
    class C:virtual public A
    class D:public B,C
```

&emsp;&emsp;虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。本例中的 A 就是一个**虚基类**。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

&emsp;&emsp;普通继承是按照构造函数出现的顺序依次调用的。对于虚继承来说，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数。

## 5、其它

### 5.1 new 和 malloc

+ new/delete是操作符，malloc/free是函数
+ new/delete不只是分配内存，还会调用构造和析构函数。new可以认为是构造函数+malloc
+ new出来的指针是包含类型信息的，malloc返回 的是void*

### 5.2 main函数执行前后发生了什么？

#### 5.2.1 main函数执行前

&emsp;&emsp;设置栈指针；  
&emsp;&emsp;初始化static静态和global全局变量(包括全局对象的初始化)，即data段的内容；  
&emsp;&emsp;给未初始化部分的全局变量赋初值；  
&emsp;&emsp;然后才真正运行main函数；  

#### 5.3.2 main函数执行后

&emsp;&emsp;main函数return后，执行```atexit(func_3);```注册的函数，后注册的先执行

### 5.3 静态转换(static_cast)和动态转换(dynamic_cast)

#### 5.3.1 静态转换

+ 基本数据类型的转换（如将int类型转换为char类型）

+ 用于类层次结构中父类和子类之间指针或引用的转换。（有继承关系的）

  + 上行转换：将子类的指针或引用转换成父类表示，这是安全可行的。
  + 下行转换：但是将父类的指针或引用转换成子类表示时，就是不安全的（如果没有动态类型检查的话）

#### 5.3.2 动态转换

&emsp;&emsp;使用dynamic_cast的好处在于，当想要将父类的指针或引用转换成子类表示时，dynamic_cast具有类型检查的功能，这使其比static_cast更加安全。但不支持基本数据类型转换。

&emsp;&emsp;动态类型转换dynamic_cast经常使用在多态场景下，基类和派生类的相互转换，并且比static_cast更为安全，但效率比较低。而且我们可以通过**判断转换后的指针值是否为NULL**判断是否转换成功。
