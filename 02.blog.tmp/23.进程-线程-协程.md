### 可重入和线程安全

&emsp;&emsp;可重入函数，与多线程无关，可重入概念是依据单一线程提出来的。当然，多线程可重入是他的扩展。  
&emsp;&emsp;一个函数被同一个线程调用2次以上，得到的结果具有可再现性(多次调用函数，得到的结果是一样的)。那么我们说这个函数是可重入的。

&emsp;&emsp;为了保证函数是可重入的，需要做到以下几点：

+ 不在函数内部使用静态或者全局数据
+ 不返回静态或者全局数据，所有的数据都由函数调用者提供
+ 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据
+ 如果必须访问全局数据，使用互斥锁来保护
+ 不调用不可重入函数

### 进程间通信方式

为什么进程间需要通信？

+ 数据传输

一个进程需要将它的数据发送给另一个进程;

+ 资源共享

多个进程之间共享同样的资源;

+ 通知事件

一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件;

+ 进程控制

有些进程希望完全控制另一个进程的执行(如Debug进程)，该控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。

#### 管道

```pipe(int pipefd[2])```，```pipefd```中的2个文件描述符，一个用于写数据，一个用于读数据。  
读写互相阻塞，一个管道只可以单向通信。

+ 命名管道

命名管道是一个真实存在的文件，可以供任意2个进行数据传输。

#### 消息队列

消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。  
消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。   

消息队列**生命周期随内核**，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。  

消息队列**不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。

#### 共享内存

共享内存是一块单独的物理空间，和其他进程对应的物理空间无关。
共享内存是这五种进程间通信方式中**效率最高**的。但是因为共享内存没有提供相应的互斥机制，所以一般共享内存都和信号量配合起来使用。

#### 信号量

PV操作，进程间的锁，消费/生产模型。

#### 信号

```Ctrl+C```和```kill -9```等发出的信号，通知接收进程某个事件已经发生。

#### socket

TCP/UDP

#### linux下的dbus

DBus 底层是基于Socket的， Unix域的socket,  为了提高通信速度， 去掉了socket的循环等待机制。

#### 总结

管道、消息队列读写数据的时候，都涉及到用户态和内核态的数据切换。共享内存则没有此问题。