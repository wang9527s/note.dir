状态模式的定义只有一句有且只有一句话是对的，就是这句：**“允许一个对象在其内部状态改变时改变它的行为”**

```bash
cmake_minimum_required(VERSION 3.16)

project(untitled LANGUAGES CXX)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Core)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Core)

add_executable(untitled
  main.cpp
)
target_link_libraries(untitled Qt${QT_VERSION_MAJOR}::Core)

include(GNUInstallDirs)
install(TARGETS untitled
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)
```

```cpp

#include <QCoreApplication>
#include <QDebug>
#include <QTimer>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

namespace Machine {

// 主状态：连接的整体阶段
enum class MainState {
    NotConnected,
    Connecting,
    Connected,
    Disconnected
};

// 子状态：更详细的状态
enum class SubState {
    None,
    Retry,
    Authenticating,
    PeerConfirmation,
    SelfConfirmation,
    ConnectionSuccess,
    ConnectionFailed,
    DisconnectRequested,
    PeerReleased,
    SelfReleased,
    TimeoutDisconnected,
    DisconnectedComplete
};

// 事件（动作）
enum class Action {
    StartConnection,
    RetryConnection,
    ConfirmAuthentication,
    ConfirmPeer,
    ConfirmSelf,
    ConnectionSuccess,
    Disconnect,
    PeerRelease,
    SelfRelease,
    TimeoutDisconnect,
    ConnectionFailure,
    CompleteDisconnection
};

// 字符串输出（方便调试）
std::string to_string(MainState state)
{
    switch (state) {
    case MainState::NotConnected: return "NotConnected";
    case MainState::Connecting: return "Connecting";
    case MainState::Connected: return "Connected";
    case MainState::Disconnected: return "Disconnected";
    }
    return "Unknown";
}

std::string to_string(SubState state)
{
    switch (state) {
    case SubState::None: return "None";
    case SubState::Retry: return "Retry";
    case SubState::Authenticating: return "Authenticating";
    case SubState::PeerConfirmation: return "PeerConfirmation";
    case SubState::SelfConfirmation: return "SelfConfirmation";
    case SubState::ConnectionSuccess: return "ConnectionSuccess";
    case SubState::ConnectionFailed: return "ConnectionFailed";
    case SubState::DisconnectRequested: return "DisconnectRequested";
    case SubState::PeerReleased: return "PeerReleased";
    case SubState::SelfReleased: return "SelfReleased";
    case SubState::TimeoutDisconnected: return "TimeoutDisconnected";
    case SubState::DisconnectedComplete: return "DisconnectedComplete";
    }
    return "Unknown";
}

std::string to_string(Action action)
{
    switch (action) {
    case Action::StartConnection: return "StartConnection";
    case Action::RetryConnection: return "RetryConnection";
    case Action::ConfirmAuthentication: return "ConfirmAuthentication";
    case Action::ConfirmPeer: return "ConfirmPeer";
    case Action::ConfirmSelf: return "ConfirmSelf";
    case Action::ConnectionSuccess: return "ConnectionSuccess";
    case Action::Disconnect: return "Disconnect";
    case Action::PeerRelease: return "PeerRelease";
    case Action::SelfRelease: return "SelfRelease";
    case Action::TimeoutDisconnect: return "TimeoutDisconnect";
    case Action::ConnectionFailure: return "ConnectionFailure";
    case Action::CompleteDisconnection: return "CompleteDisconnection";
    }
    return "Unknown";
}

} // namespace Machine

using namespace Machine;

// --- 状态机类 ---
template <typename MainState, typename SubState, typename Event>
class MainSubStateMachine
{
public:
    using TransitionTable = std::unordered_map<Event, std::pair<MainState, SubState>>;
    using StateMap = std::unordered_map<MainState, TransitionTable>;

    MainSubStateMachine(MainState initialMainState, SubState initialSubState)
        : currentMainState(initialMainState), currentSubState(initialSubState) {}

    void setTransitions(MainState mainState, const TransitionTable& transitions) {
        states[mainState] = transitions;
    }

    bool transition(Event event)
    {
        if (auto it = states.find(currentMainState); it != states.end()) {
            const auto& transitions = it->second;
            if (auto transIt = transitions.find(event); transIt != transitions.end()) {
                currentMainState = transIt->second.first;
                currentSubState = transIt->second.second;
                return true;
            }
        }
        return false;
    }

    MainState getCurrentMainState() const { return currentMainState; }
    SubState getCurrentSubState() const { return currentSubState; }

private:
    MainState currentMainState;
    SubState currentSubState;
    StateMap states;
};

// --- 主程序入口 ---
int main(int argc, char* argv[])
{
    QCoreApplication a(argc, argv);

    MainSubStateMachine<MainState, SubState, Action> fsm(MainState::NotConnected, SubState::None);

    // 状态转移定义
    fsm.setTransitions(MainState::NotConnected, {
        {Action::StartConnection, {MainState::Connecting, SubState::None}}
    });

    fsm.setTransitions(MainState::Connecting, {
        {Action::RetryConnection, {MainState::Connecting, SubState::Retry}},
        {Action::ConfirmAuthentication, {MainState::Connecting, SubState::Authenticating}},
        {Action::ConfirmPeer, {MainState::Connecting, SubState::PeerConfirmation}},
        {Action::ConfirmSelf, {MainState::Connecting, SubState::SelfConfirmation}},
        {Action::ConnectionSuccess, {MainState::Connected, SubState::ConnectionSuccess}},
        {Action::ConnectionFailure, {MainState::Disconnected, SubState::ConnectionFailed}}
    });

    fsm.setTransitions(MainState::Connected, {
        {Action::Disconnect, {MainState::Disconnected, SubState::DisconnectRequested}},
        {Action::TimeoutDisconnect, {MainState::Disconnected, SubState::TimeoutDisconnected}}
    });

    fsm.setTransitions(MainState::Disconnected, {
        {Action::RetryConnection, {MainState::Connecting, SubState::Retry}},
        {Action::PeerRelease, {MainState::Disconnected, SubState::PeerReleased}},
        {Action::SelfRelease, {MainState::Disconnected, SubState::SelfReleased}},
        {Action::CompleteDisconnection, {MainState::NotConnected, SubState::DisconnectedComplete}}
    });

    // 状态测试函数
    auto doActions = [&](const std::string& name, std::vector<Action> events) {
        qInfo() << "\n==> 流程：" << QString::fromStdString(name);
        std::string log = "Init -> 当前主状态: " + to_string(fsm.getCurrentMainState())
            + ", 当前子状态: " + to_string(fsm.getCurrentSubState());
        qInfo() << QString::fromStdString(log);

        for (const auto& event : events) {
            std::string elog = "Action: " + to_string(event);
            bool success = fsm.transition(event);
            if (!success) {
                elog = "error: " + elog;
            }
            elog += " -> 当前主状态: " + to_string(fsm.getCurrentMainState())
                + ", 当前子状态: " + to_string(fsm.getCurrentSubState());
            qInfo() << QString::fromStdString(elog);
        }
    };

    // --- 测试流程 ---

    doActions("连接失败流程", {
        Action::StartConnection,
        Action::ConfirmAuthentication,
        Action::ConfirmPeer,
        Action::ConnectionFailure
    });

    doActions("重试后连接成功流程", {
        Action::RetryConnection,
        Action::ConfirmAuthentication,
        Action::ConfirmPeer,
        Action::ConfirmSelf,
        Action::ConnectionSuccess
    });

    doActions("用户断开连接流程", {
        Action::Disconnect,
        Action::PeerRelease,
        Action::SelfRelease,
        Action::CompleteDisconnection
    });

    doActions("超时断开流程", {
        Action::StartConnection,
        Action::ConfirmAuthentication,
        Action::ConfirmPeer,
        Action::ConfirmSelf,
        Action::ConnectionSuccess,
        Action::TimeoutDisconnect,
        Action::SelfRelease,
        Action::PeerRelease,
        Action::CompleteDisconnection
    });

    QTimer::singleShot(1000, &a, &QCoreApplication::quit);
    return a.exec();
}

```

```cpp
#include <QCoreApplication>
#include <QDebug>
#include <QTimer>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

namespace Machine {

// --- 主状态类 ---
// 连接的整体阶段
class MainState {
public:
    virtual std::string toString() const = 0;
    virtual ~MainState() = default;
};

// 各种主状态实现
class NotConnected : public MainState {
public:
    std::string toString() const override { return "NotConnected"; }
};

class Connecting : public MainState {
public:
    std::string toString() const override { return "Connecting"; }
};

class Connected : public MainState {
public:
    std::string toString() const override { return "Connected"; }
};

class Disconnected : public MainState {
public:
    std::string toString() const override { return "Disconnected"; }
};

// --- 子状态类 ---
// 更详细的状态
class SubState {
public:
    virtual std::string toString() const = 0;
    virtual ~SubState() = default;
};

// 各种子状态实现
class None : public SubState {
public:
    std::string toString() const override { return "None"; }
};

class Retry : public SubState {
public:
    std::string toString() const override { return "Retry"; }
};

class Authenticating : public SubState {
public:
    std::string toString() const override { return "Authenticating"; }
};

class PeerConfirmation : public SubState {
public:
    std::string toString() const override { return "PeerConfirmation"; }
};

class SelfConfirmation : public SubState {
public:
    std::string toString() const override { return "SelfConfirmation"; }
};

class ConnectionSuccess : public SubState {
public:
    std::string toString() const override { return "ConnectionSuccess"; }
};

class ConnectionFailed : public SubState {
public:
    std::string toString() const override { return "ConnectionFailed"; }
};

class DisconnectRequested : public SubState {
public:
    std::string toString() const override { return "DisconnectRequested"; }
};

class PeerReleased : public SubState {
public:
    std::string toString() const override { return "PeerReleased"; }
};

class SelfReleased : public SubState {
public:
    std::string toString() const override { return "SelfReleased"; }
};

class TimeoutDisconnected : public SubState {
public:
    std::string toString() const override { return "TimeoutDisconnected"; }
};

class DisconnectedComplete : public SubState {
public:
    std::string toString() const override { return "DisconnectedComplete"; }
};

// --- 事件（动作）类 ---
// 动作类的定义不需要修改，还是通过枚举来控制
enum class Action {
    StartConnection,
    RetryConnection,
    ConfirmAuthentication,
    ConfirmPeer,
    ConfirmSelf,
    ConnectionSuccess,
    Disconnect,
    PeerRelease,
    SelfRelease,
    TimeoutDisconnect,
    ConnectionFailure,
    CompleteDisconnection
};

std::string to_string(Action action)
{
    switch (action) {
    case Action::StartConnection: return "StartConnection";
    case Action::RetryConnection: return "RetryConnection";
    case Action::ConfirmAuthentication: return "ConfirmAuthentication";
    case Action::ConfirmPeer: return "ConfirmPeer";
    case Action::ConfirmSelf: return "ConfirmSelf";
    case Action::ConnectionSuccess: return "ConnectionSuccess";
    case Action::Disconnect: return "Disconnect";
    case Action::PeerRelease: return "PeerRelease";
    case Action::SelfRelease: return "SelfRelease";
    case Action::TimeoutDisconnect: return "TimeoutDisconnect";
    case Action::ConnectionFailure: return "ConnectionFailure";
    case Action::CompleteDisconnection: return "CompleteDisconnection";
    }
    return "Unknown";
}

} // namespace Machine

using namespace Machine;

// --- 状态机类 ---
// 模板改为支持类实例作为状态
template <typename MainState, typename SubState, typename Event>
class MainSubStateMachine
{
public:
    using TransitionTable = std::unordered_map<Event, std::pair<MainState*, SubState*>>;
    using StateMap = std::unordered_map<MainState*, TransitionTable>;

    MainSubStateMachine(MainState* initialMainState, SubState* initialSubState)
        : currentMainState(initialMainState), currentSubState(initialSubState) {}

    void setTransitions(MainState* mainState, const TransitionTable& transitions) {
        states[mainState] = transitions;
    }

    bool transition(Event event)
    {
        if (auto it = states.find(currentMainState); it != states.end()) {
            const auto& transitions = it->second;
            if (auto transIt = transitions.find(event); transIt != transitions.end()) {
                currentMainState = transIt->second.first;
                currentSubState = transIt->second.second;
                return true;
            }
        }
        return false;
    }

    MainState* getCurrentMainState() const { return currentMainState; }
    SubState* getCurrentSubState() const { return currentSubState; }

private:
    MainState* currentMainState;
    SubState* currentSubState;
    StateMap states;
};

// --- 主程序入口 ---
// 创建状态对象
int main(int argc, char* argv[])
{
    QCoreApplication a(argc, argv);

    NotConnected notConnectedState;
    Connecting connectingState;
    Connected connectedState;
    Disconnected disconnectedState;

    None noneSubState;
    Retry retrySubState;
    Authenticating authenticatingSubState;
    PeerConfirmation peerConfirmationSubState;
    SelfConfirmation selfConfirmationSubState;
    ConnectionSuccess connectionSuccessSubState;
    ConnectionFailed connectionFailedSubState;
    DisconnectRequested disconnectRequestedSubState;
    PeerReleased peerReleasedSubState;
    SelfReleased selfReleasedSubState;
    TimeoutDisconnected timeoutDisconnectedSubState;
    DisconnectedComplete disconnectedCompleteSubState;

    MainSubStateMachine<MainState, SubState, Action> fsm(&notConnectedState, &noneSubState);

    // 状态转移定义
    fsm.setTransitions(&notConnectedState, {
        {Action::StartConnection, {&connectingState, &noneSubState}}
    });

    fsm.setTransitions(&connectingState, {
        {Action::RetryConnection, {&connectingState, &retrySubState}},
        {Action::ConfirmAuthentication, {&connectingState, &authenticatingSubState}},
        {Action::ConfirmPeer, {&connectingState, &peerConfirmationSubState}},
        {Action::ConfirmSelf, {&connectingState, &selfConfirmationSubState}},
        {Action::ConnectionSuccess, {&connectedState, &connectionSuccessSubState}},
        {Action::ConnectionFailure, {&disconnectedState, &connectionFailedSubState}}
    });

    fsm.setTransitions(&connectedState, {
        {Action::Disconnect, {&disconnectedState, &disconnectRequestedSubState}},
        {Action::TimeoutDisconnect, {&disconnectedState, &timeoutDisconnectedSubState}}
    });

    fsm.setTransitions(&disconnectedState, {
        {Action::RetryConnection, {&connectingState, &retrySubState}},
        {Action::PeerRelease, {&disconnectedState, &peerReleasedSubState}},
        {Action::SelfRelease, {&disconnectedState, &selfReleasedSubState}},
        {Action::CompleteDisconnection, {&notConnectedState, &disconnectedCompleteSubState}}
    });

    // 状态测试函数
    auto doActions = [&](const std::string& name, std::vector<Action> events) {
        qInfo() << "\n==> 流程：" << QString::fromStdString(name);
        std::string log = "Init -> 当前主状态: " + fsm.getCurrentMainState()->toString()
            + ", 当前子状态: " + fsm.getCurrentSubState()->toString();
        qInfo() << QString::fromStdString(log);

        for (const auto& event : events) {
            std::string elog = "Action: " + to_string(event);
            bool success = fsm.transition(event);
            if (!success) {
                elog = "error: " + elog;
            }
            elog += " -> 当前主状态: " + fsm.getCurrentMainState()->toString()
                + ", 当前子状态: " + fsm.getCurrentSubState()->toString();
            qInfo() << QString::fromStdString(elog);
        }
    };

    // --- 测试流程 ---
    doActions("连接失败流程", {
        Action::StartConnection,
        Action::ConfirmAuthentication,
        Action::ConfirmPeer,
        Action::ConnectionFailure
    });

    doActions("重试后连接成功流程", {
        Action::RetryConnection,
        Action::ConfirmAuthentication,
        Action::ConfirmPeer,
        Action::ConfirmSelf,
        Action::ConnectionSuccess
    });

    doActions("用户断开连接流程", {
        Action::Disconnect,
        Action::PeerRelease,
        Action::SelfRelease,
        Action::CompleteDisconnection
    });

    doActions("超时断开流程", {
        Action::StartConnection,
        Action::ConfirmAuthentication,
        Action::ConfirmPeer,
        Action::ConfirmSelf,
        Action::ConnectionSuccess,
        Action::TimeoutDisconnect,
        Action::SelfRelease,
        Action::PeerRelease,
        Action::CompleteDisconnection
    });

    QTimer::singleShot(1000, &a, &QCoreApplication::quit);
    return a.exec();
}
```