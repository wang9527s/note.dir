
### 1、gdb

#### 1. gdb直接运行程序

```bash
gdb --args  ./example/calc/build/calc-rpc-demo server

# 添加断点
b /home/wangbin/speaker-l15a/iot_test_demo/lyra_rpc/rpc/core/rpc_json_client.cpp:62

run

# 查看堆栈
bt
```

#### 2. 添加断点

程序需要有调试信息，才能命中断点

```bash
# 添加调试信息
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O0 -g")
```

```bash
# 断点添加成功
(gdb) break wlogger_impl.hpp:97
Breakpoint 2 at 0x55555557a71e: file /home/wangbin/code/code.study.example/cpp/vendor/wlogger/src/../include/wlogger_impl.hpp, line 97.
```

```bash
$ file a.out 
a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2178cca3334224888c98ed2859b28f3efe41090b, for GNU/Linux 3.2.0, with debug_info, not stripped
```

```bash
$ readelf -S a.out | grep debug
  [31] .debug_aranges    PROGBITS         0000000000000000  00050193
  [32] .debug_info       PROGBITS         0000000000000000  00053d23
  [33] .debug_abbrev     PROGBITS         0000000000000000  0009c0e5
  [34] .debug_line       PROGBITS         0000000000000000  0009df7d
  [35] .debug_str        PROGBITS         0000000000000000  000addf5
  [36] .debug_line_str   PROGBITS         0000000000000000  001008db
  [37] .debug_rnglists   PROGBITS         0000000000000000  00101191
```

#### 3. 调试 dump

  直接使用gdb，而不是交叉工具中的gdb

```bash
gdb ./a.out /tmp/core-a.out-5946-1750324522
```

如果是不带符号的so，需要设置符号。**下面的操作 最好使用绝对路径**

```bash
# 设置so的符号路径
(gdb) set solib-search-path /home/wangbin/nfs_wb/symbol

# 如果 solib-search-path后 还是看不了堆栈，可以使用symbol-file，手动加载符号
(gdb) symbol-file  /mnt/aaa/symbol/a.out
Reading symbols from /mnt/aaa/symbol/a.out...
(No debugging symbols found in /mnt/aaa/symbol/a.out)
```

```bash
# 设置系统库和符号（比如 /lib, /usr/lib 中的内容）
(gdb) set sysroot /home/wangbin/.toolchain/gcc-11.1.0-20210608/arm-linux-gnueabihf/libc
```


### 2、dump的生成 (linux)

#### 1. 基本使用

linux上执行如下两步，可以在指定目录中生成dump文件  

**1. 生成dump文件**

  执行 ```ulimit -c unlimited``` 命令（可以在bashrc中设置）

**2. 生成dump的规则**

  修改 ```/proc/sys/kernel/core_pattern```文件，修改为```/tmp/core-%e-%p-%t```


```bash
# 将dump文件保存到 /tmp/coredump 文件夹中
echo "/tmp/coredump/core-%e-%p-%h-%t" > /proc/sys/kernel/core_pattern
```

#### 2. 进阶

**永久生效**

在 ```/etc/sysctl.conf``` 中，添加```kernel.core_pattern = /tmp/cores/core.%e.%p.%t```；然后执行```sudo sysctl -p```。

**设置外部脚本处理dump文件**

想在dump生成的时候，拷贝一份a.out放到一起，但在wsl中测试失败，脚本执行失败。

### 3、lldb （mac）

  mac上使用gdb无法调试，需要使用lldb，使用方法类似gdb

```bash
lldb a.out
run
bt
```

### python 虚拟环境

```bash
sudo apt install python3-venv
python3 -m venv ~/.venv/paddle-ocr
# 进入虚拟环境
source ~/.venv/paddle-ocr/bin/activate

... 
pip install opencv-python pillow numpy scikit-learn lmdb \
	matplotlib paddleocr paddlepaddle

...

# 退出虚拟环境
deactivate
```

---

### gdb发现无符号
遇到一个奇怪的问题，release版的编译程序symbol/a.out中没有符号，无法gdb dump文件。

修改如下编译选项，改为 ```-g```、```-g -O3```、```-g -O0```都不行，symbol中的程序是 ```ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, stripped```

```bash
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -g")

set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_DEBUG} -g")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -g")
set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE} -g")
```

最后在cmake的编译追加如下选项，```-D CMAKE_BUILD_TYPE=RelWithDebInfo ```问题解决。**注意，追加，防止被其他参数覆盖**。

```bash
$ file ./a.out
./a.out: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, with debug_info, not stripped
```

### 

-g -O0 出现了链接错误
undefined reference to UpdateRemoteDeviceInfo

$ find ./build/-name "lib*.a" -exec nm -C {} \;  | grep UpdateRemoteDeviceInfo
      U xx::xx::UpdateRemoteDeviceInfo()
	  
最后定位是，函数调用的时候，伪代码如下，UpdateRemoteDeviceInfo不会走，-O3优化了这块，-O0不优化，所以有编译错误

{
#if !defined(AAA)
	...
	return;
#endif
	UpdateRemoteDeviceInfo()
}


吐槽 项目真大，明明有实现，找了半天才找到为什么实现没有编译进来（在CMakeLists.txt中整个network模块被裁掉了）