
## 1. syslog

**开启指定进程的Debug日志**

修改syslog-ng.conf

```bash

filter f_messages {
    level(alert .. warning)
        or program("kernel");
};

改为

filter f_messages {
    level(alert .. warning)
        or (level(debug .. info) and program("demo_log"))
        or program("kernel");
};

```

上述配置文件中的demo_log和就是下面代码中的demo_log

```cpp
// 开启syslog
openlog("demo_log", LOG_PID, facility);
```

## 2. 替换printf为指定函数，实现同时输出到终端和文件中

  使用ALOG替换printf

```cpp
#pragma once
#include <iostream>
#include <fstream>
#include <string>
#include <cstdarg>
#include <ctime>
#include <mutex>
#include <iomanip>

namespace ALog {

class ALogger {
public:
    // 获取单例实例
    static ALogger& instance() {
        static ALogger instance;   // C++11 保证线程安全
        return instance;
    }

    // 禁止拷贝构造与赋值
    ALogger(const ALogger&) = delete;
    ALogger& operator=(const ALogger&) = delete;

    // 可变参数日志输出（控制台 + 文件，带时间戳）
    void log(const char* format, ...) {
        std::lock_guard<std::mutex> lock(mtx);

        // 获取当前时间
        auto t = std::time(nullptr);
        std::tm tstruct;
#ifdef _WIN32
        localtime_s(&tstruct, &t);
#else
        localtime_r(&t, &tstruct);
#endif
        char timebuf[32];
        std::strftime(timebuf, sizeof(timebuf), "[%Y-%m-%d %H:%M:%S] ", &tstruct);

        // 格式化日志内容
        char logbuf[1024];
        va_list args;
        va_start(args, format);
        vsnprintf(logbuf, sizeof(logbuf), format, args);
        va_end(args);

        // 输出到控制台
        std::cout << timebuf << logbuf;
        std::cout.flush();

        // 输出到文件
        if (log_file.is_open()) {
            log_file << timebuf << logbuf;
            log_file.flush();
        }
    }

private:
    std::ofstream log_file;
    std::string log_filename;
    std::mutex mtx;

    // 构造函数
    ALogger() {
        generateLogFileName();
        log_file.open(log_filename, std::ios::app);

        if (!log_file.is_open()) {
            std::cerr << "Failed to open log file: " << log_filename << std::endl;
        } else {
            std::cout << "Logging to file: " << log_filename << std::endl;
        }
    }

    ~ALogger() {
        if (log_file.is_open()) {
            log_file.close();
        }
    }

    void generateLogFileName() {
        std::time_t now = std::time(nullptr);
        std::tm tstruct;
#ifdef _WIN32
        localtime_s(&tstruct, &now);
#else
        localtime_r(&now, &tstruct);
#endif
        char buf[80];
        std::strftime(buf, sizeof(buf), "output_%Y-%m-%d.txt", &tstruct);
        log_filename = buf;
    }
};

} // namespace ALog

#define ALOG(fmt, ...) ALog::ALogger::instance().log(fmt, ##__VA_ARGS__)
```