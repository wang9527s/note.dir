
### CPU缓存一致性

缓存一致性是指多个处理器或多核之间共享的数据在各自的缓存中保持一致的机制。在多核处理器系统中，由于每个核心都有自己的缓存，当一个核心修改了某个内存位置的值时，其他核心的缓存中的对应值可能会过时。这可能导致数据不一致的问题。  

L1和L2是每个核独有的缓存，L3是所有核共享的缓存；再往下就是主存（内存）了。

TODO 有点难搞

线程A和B同时执行num++，可能会出现一下问题，导致结果是未预取的。(不考虑cpu的乱序执行，只考虑缓存)，距离如下：
    1. A执行完成后，结果写入缓存，尚未写入主存；此时B读取了主存中的数据。
    2. A执行完成后，数据以及写入主存；但B从另外一个核(A和B运行在不同的核上)的L2级缓存中读取了数据。
   
原子操作和mutex不能解决缓存一致性的问题。
---

cpu缓存一致性和cpu乱序执行

+ 比较并交换(compare and swap, CAS)

__sync_bool_compare_and_swap 是一个原子比较和交换（CAS）操作，通常用于实现多线程之间的同步和并发控制（无所队列）。
- 第一个参数是要操作的目标变量的地址。
- 第二个参数是期望值。如果目标变量的值等于这个期望值，则会执行交换操作。
- 第三个参数是新值。如果交换操作执行成功，目标变量的值将被设置为这个新值。
函数的返回值是一个布尔值，表示交换操作是否成功执行。如果成功执行，返回 true；否则返回 false。




原子变量和 __sync_bool_compare_and_swap 函数本身并不能直接解决缓存一致性的问题。它们主要用于确保对共享数据的原子操作，从而避免竞态条件和确保线程安全。


