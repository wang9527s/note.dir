- [1、C基础部分](#1c基础部分)
  - [sizeof和strlen](#sizeof和strlen)
  - [基本数据类型](#基本数据类型)
  - [数组](#数组)
  - [pragma pack(n)](#pragma-packn)
- [2、基础语法](#2基础语法)
  - [1. const和指针](#1-const和指针)
  - [2. 引用](#2-引用)
  - [3. const](#3-const)
  - [4. static](#4-static)
  - [5. class](#5-class)
- [3、函数提高](#3函数提高)
  - [3.1 函数占位符](#31-函数占位符)
  - [3.2 函数重载](#32-函数重载)
  - [3.3 内联函数](#33-内联函数)
- [4、对象的初始化和清理](#4对象的初始化和清理)
  - [4.1 C++中 struct和class的区别](#41-c中-struct和class的区别)
    - [4.1.1 唯一的区别就在于 默认的访问权限不同](#411-唯一的区别就在于-默认的访问权限不同)
    - [4.1.2 堆栈](#412-堆栈)
  - [4.2 构造函数](#42-构造函数)
    - [4.2.1 普通构造函数（隐式调用）](#421-普通构造函数隐式调用)
    - [4.2.2 拷贝构造函数和赋值构造函数](#422-拷贝构造函数和赋值构造函数)
    - [4.2.3 编译器自动添加的函数](#423-编译器自动添加的函数)
    - [4.2.4 构造函数执行顺序](#424-构造函数执行顺序)
    - [4.2.5 初始化列表](#425-初始化列表)
    - [4.2.6 静态成员](#426-静态成员)
  - [4.3 C++对象模型和this指针](#43-c对象模型和this指针)
    - [4.3.1成员变量和成员函数分开存储](#431成员变量和成员函数分开存储)
    - [4.3.2 this指针](#432-this指针)
    - [4.3.3 空指针访问成员函数](#433-空指针访问成员函数)
    - [4.3.4 const 修饰成员函数和类](#434-const-修饰成员函数和类)
  - [4.4 友元](#44-友元)
  - [4.5 运算符重载](#45-运算符重载)
  - [4.6 继承](#46-继承)
    - [4.6.1 继承和访问权限](#461-继承和访问权限)
    - [4.6.2 抽象类和纯虚函数](#462-抽象类和纯虚函数)
    - [4.6.3 多态和虚析构函数](#463-多态和虚析构函数)
    - [4.6.4 虚函数表](#464-虚函数表)
    - [4.6.5 虚继承](#465-虚继承)
  - [4.7 只能在堆/栈上实例化的类](#47-只能在堆栈上实例化的类)
    - [4.7.1 只能在栈上(静态对象)](#471-只能在栈上静态对象)
    - [4.7.2 只能在堆上(动态对象)](#472-只能在堆上动态对象)
- [5、其它](#5其它)
  - [5.1 new/delete 和 malloc/free](#51-newdelete-和-mallocfree)
    - [5.1.1 内存泄露和内存越界](#511-内存泄露和内存越界)
  - [5.2 main函数执行前后发生了什么？](#52-main函数执行前后发生了什么)
    - [5.2.1 main函数执行前](#521-main函数执行前)
    - [5.2.2 main函数执行后](#522-main函数执行后)
  - [5.3 静态转换(static\_cast)和动态转换(dynamic\_cast)](#53-静态转换static_cast和动态转换dynamic_cast)
    - [5.3.1 静态转换](#531-静态转换)
    - [5.3.2 动态转换](#532-动态转换)
  - [5.4 RTTI](#54-rtti)


C++笔记，部分内容来自[github分享](https://github.com/0voice/cpp_new_features)

## 1、C基础部分

### sizeof和strlen

&emsp;&emsp;sizeof是一个操作符，strlen是库函数。  
&emsp;&emsp;sizeof的参数是数据的类型、变量和表达式，而strlen只能以结尾为‘\0’的字符串作参数。  
&emsp;&emsp;编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。  

&emsp;&emsp;数组做sizeof的参数不退化，传递给strlen就退化为指针了

+ sizeof

&emsp;&emsp;sizeof(数组)，整个数组所占空间大小。  
&emsp;&emsp;sizeof(指针)，指针本身所占空间大小。

```cpp
int num[10];
int * pNum = num;
sizeof(num);        // 40
sizeof(pNum);       // 8
```

### 基本数据类型

单精度浮点数（float）通常占用4个字节（32位）的内存空间。有效位数通常约为6-9位。
双精度浮点数（double）通常占用8个字节（64位）的内存空间。有效位数通常约为15-17位。

### 数组

```cpp
//当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针
void Func(char a[100]){
}
//防止蜕化（数组引用）
void Func(char (&a)[100]){
}
```

```cpp
int x[10]; int *px=x;
x[i]、*(px+i)、 *(x+i) 和px[i]具有相同功能的功能:访问数组第i+1个数组元素

 *(*(a+0) +１) ==  a[0][1]
```

### pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐

```cpp
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```

## 2、基础语法

### 1. const和指针

| 指针常量 | 常量指针 |
| ------- | ------- |
| const int * p	| int * const p=&a |
| 该指针指向的是常量|	指针本身是常量|
| 可以修改 指针的指向	|可修改 指针指向的值|

### 2. 引用

&emsp;&emsp;引用有如下特点

- 必须初始化  
  
- 引用在初始化后，不可以改变  
  
- 引用可以作为返回值
  
  注意悬挂引用（空引用）

&emsp;&emsp;上诉的特点和指针很类似，但引用是不占内存空间的。不过在struct中实际测试，引用是占用空间的。所以，“引用的本质在c++内部实现是一个常量指针”的说法比较靠谱。  
&emsp;&emsp;编译会将```int& ref = a```自动转换为```int* const ref = &a```。

### 3. const

+ 作用
  
  - 修饰常量：常量不可修改。
  - 修饰函数返回值：返回值是常量。
  - 修饰成员函数：代表函数不可以修改成员变量。（所以也不可以在函数体内部调用普通函数）
  - const常对象只能调用常函数，不可以调用不同函数

+ const 与 #define 的比较

| 宏定义 #define  |  const 常量 |
| ------------ | ------------ |
| 宏定义，相当于字符替换，无数据类型  | 常量数据类型  |
| 预处理器处理，无类型安全检查  |  编译器处理，有类型安全检查 |
| 存储在代码段  | 存储在全局常亮或栈区  |
| 可通过 #undef 取消 | 不可取消  |
| 无法调试| 有些调试工具可以调试const常量 |

### 4. static

+ 修饰普通变量

&emsp;&emsp;修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。

+ 修饰普通函数

&emsp;&emsp;**表明函数的作用范围，仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。

+ 修饰成员变量
  
&emsp;&emsp;修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。

+ 修饰成员函数

&emsp;&emsp;修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

### 5. class

+ 同名变量

  子类如果有和基类的同名变量，不会覆盖基类的变量。两个变量同时存在。

```cpp
B b;
b.A::num = 990;
b.B::num
```

## 3、函数提高

### 3.1 函数占位符

&emsp;&emsp;占位符可以拥有默认参数，如果占位符没有写默认参数，那么调用的时候必须填写。包含占位符的函数声明如下：```void func2(int a,int = 1){}```

### 3.2 函数重载

- 参数int & a 和参数 const inst & a是不同的；

- func2(int a, int b = 10)和func2(int a)是相同的，使用func2(0)的时候无法区分想要调用的是第一个还是第二个函数

### 3.3 内联函数

&emsp;&emsp;内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。

&emsp;&emsp;每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

&emsp;&emsp;是否内联是由编译器控制，程序员不可控（只提供建议）


## 4、对象的初始化和清理

### 4.1 C++中 struct和class的区别

#### 4.1.1 唯一的区别就在于 默认的访问权限不同

#### 4.1.2 堆栈

```
我：struct一般使用简单的逻辑，复杂的逻辑才使用class（约定熟成）
他：struct一般存放在栈（速度快）上，只存放简单的逻辑，使用复杂的逻辑会让栈溢出。

but:
1. new struct 同样在堆上。
2. 如果一个struct/class对象，占用空间的只有成员变量和成员函数，似乎不存在数量级的差异，栈溢出。
```
今天一个面试官说，。但是```new struct```同样在堆空间中。

### 4.2 构造函数

#### 4.2.1 普通构造函数（隐式调用）

```cpp
class Person {
    int age;
public:
    Person(int age):age(age){}
};
```

```cpp
//2.1  括号法，常用
Person p1(10);

//2.2 显式法
Person p2 = Person(10); 
Person p3 = Person(p2);

//2.3 隐式转换法   explicit关键字可以禁止隐式转换
Person p4 = 10; // Person p4 = Person(10); 
Person p5 = p4; // Person p5 = Person(p4); 
```

&emsp;&emsp;```Person(参数)```单独写表示生成了一个匿名对象，当前行结束后，该对象立即析构。  
&emsp;&emsp;但是，不能利用拷贝构造函数，初始化一个匿名对象，编译器认为是一个对象声明。例如```Person(p)```，编译器会将括号删除，直接表示为 ```Person p```。

#### 4.2.2 拷贝构造函数和赋值构造函数

```cpp
// 拷贝构造函数（复制构造函数）
Person(const Person& p) {}

// 赋值构造函数（重载=）
Person& operator=(const Person& p) = delete;
```

+ 拷贝构造函数调用时机

  当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数会被调用。

  C++中拷贝构造函数调用时机通常有如下三种情况：

  - 使用一个已经创建完毕的对象来初始化一个新对象  
  - 值传递的方式给函数参数传值  
  - 以值方式返回局部对象

+ 举例

```cpp
Person newman(man);     // 调用拷贝构造函数
Person newman2 = man;   // 拷贝构造
newman2 = man;          // 调用 = 赋值操作符
```

&emsp;&emsp;**复制构造函数**是去完成对未初始化的存储区的初始化，而**赋值操作符**则是处理一个已经存在的对象。

#### 4.2.3 编译器自动添加的函数

&emsp;&emsp;默认情况下，c++编译器会给一个类添加如下函数：

+ 默认构造函数(无参)
+ 默认析构函数(无参)
+ 默认拷贝构造函数，对属性进行值拷贝
+ 赋值运算符 operator=, 对属性进行值拷贝

&emsp;&emsp;如果用户自定义**有参构造函数**，c++不在提供默认无参构造，但是会提供默认拷贝构造。  
&emsp;&emsp;如果用户定义了**拷贝构造函数**，c++不会再提供**其他构造函数**

#### 4.2.4 构造函数执行顺序

1) 构造的顺序是 ：先调用对象成员的构造，再调用本类构造
2) 析构顺序与构造相反

#### 4.2.5 初始化列表

+ 必须使用参数列表初始化的情况

&emsp;&emsp;const和引用变量必须使用初始化列表进行初始化；  
&emsp;&emsp;没有默认构造函数的类成员，包括基类没有默认构造函数；

&emsp;&emsp;如果在类中声明了成员变量，并且构造函数初始化列表中也初始化了该成员变量，则只执行参数初始化列表中的构造。

#### 4.2.6 静态成员

+ 静态成员变量

  - 所有对象共享同一份数据  
  - 在编译阶段分配内存
  - 类内声明，类外初始化

+ 静态成员函数

  - 所有对象共享同一个函数  
  - 静态成员函数只能访问静态成员变量

### 4.3 C++对象模型和this指针

#### 4.3.1成员变量和成员函数分开存储

&emsp;&emsp;类内的成员变量和成员函数(代码段)分开存储，只有**非静态成员变量**才属于类的对象上。  
&emsp;&emsp;备注：虚表指针存放在对象的首部。

#### 4.3.2 this指针

&emsp;&emsp;我们知道在C++中成员变量和成员函数是分开存储的。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。

&emsp;&emsp;那么问题是：这一块代码是如何区分那个对象调用自己的呢？

&emsp;&emsp;c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**。

+ this指针的用途：

&emsp;&emsp;当形参和成员变量同名时，可用this指针来区分  
&emsp;&emsp;在类的非静态成员函数中返回对象本身，可使用return *this

#### 4.3.3 空指针访问成员函数

```cpp
Person *p=nullprt;
p->country()        // 如果country方法中没有使用this，函数可以正常运行
```

&emsp;&emsp;在类中使用成员变量和成员函数，可以不加this；编译器在展开时，自动添加this  
&emsp;&emsp;想到了一种写法 ```if (this == nullptr) return;``` **啧啧**

#### 4.3.4 const 修饰成员函数和类

+ 常函数

&emsp;&emsp;成员函数后加const后我们称为这个函数为常函数  
&emsp;&emsp;常函数内不可以修改成员属性  
&emsp;&emsp;成员属性声明时加关键字mutable后，在常函数中依然可以修改

+ 常对象

&emsp;&emsp;声明对象前加const称该对象为常对象  
&emsp;&emsp;常对象只能调用常函数

### 4.4 友元

&emsp;&emsp;友元的目的就是让一个函数或者类，可以访问另一个类中私有成员。友元有3种形式：全局函数做友元、类做友元、成员函数做友元  

&emsp;&emsp;注意: 友元关系不能被继承；友元关系是单向的，不具有交换性；友元关系不具有传递性。

### 4.5 运算符重载

&emsp;&emsp;[运算符重载](./02.C%2B%2B%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.md)

### 4.6 继承

#### 4.6.1 继承和访问权限

&emsp;&emsp;public继承，基类三种访问属性在派生类中分别变成: public, protected, private  
&emsp;&emsp;protected继承，基类三种访问属性在派生类中分别变成: protected, protected, private  
&emsp;&emsp;private继承，基类三种访问属性在派生类中分别变成: private, private, private

&emsp;&emsp;子类继承父类时，也将父类私有变量/方法继承了过来，只是对**子类不可见，不可操作**。  
&emsp;&emsp;private只有当前类和友元可以访问。  

&emsp;&emsp;子类对象加作用域可以访问到父类同名成员。

#### 4.6.2 抽象类和纯虚函数

&emsp;&emsp;纯虚函数，语法：virtual 返回值类型 函数名 （参数列表）= 0  
&emsp;&emsp;抽象类：类中包含的纯虚函数的类叫做抽象类，抽象类不可以实例化。

#### 4.6.3 多态和虚析构函数

+ 分析删除多态对象的内存释放

```cpp
Animal *animal = new Cat("Tom");
animal->Speak();

delete animal
// 在函数中调用typeid(*this).name()，可能不是自己想要的结果（md，被坑了一把）
```

&emsp;&emsp;<font color='red'>多态：</font>基类指针指向子类对象，一般来说，调用的是基类的方法；但如果基类的方法是虚函数，则调用子类方法。  
&emsp;&emsp;所以在delete基类指针的时候，有如下两种情况：

&emsp;&emsp;1) 如果基类的析构函数**不是虚析构函数**，则调用基类的析构函数  
&emsp;&emsp;2) 如果基类的析构函数**是虚析构函数**，则先调用子类的析构函数，然后调用基类的析构函数。（调用子类析构函数，释放子类new出来的空间）

#### 4.6.4 虚函数表

&emsp;&emsp;如果当前类或者基类中有virtual函数，则实例化的对象中；第一个对象是虚表指针。  
&emsp;&emsp;一个类只有一个虚函数表。在编译时，一个类的虚函数表就确定了，存放在只读数据段中。  
&emsp;&emsp;子类中与基类虚函数同名的函数，也会自动加上virtual。  

+ 普通继承

&emsp;&emsp;<font color='red'> **虚函数表实现多态的原理：** </font>首先，子类会继承基类的虚函数表中的内容（编译期决定，存放在只读区域）。  
&emsp;&emsp;如果重写了基类的虚函数会更新子类虚表的内容。如果没有重写任何基类的虚函数，那么子类和基类的虚函数表是内容是一致的。

+ 多继承

  在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。注意：

  - 子类虚函数会覆盖每一个父类的每一个同名虚函数。
  - 父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。(不能调用，编译期就已经不存在)
  - 父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。
  
#### 4.6.5 虚继承

```cpp
    class A;
    class B:public A
    class C:public A
    class D:public B,C
```

&emsp;&emsp;如上，菱形继承，D中需要继承2份A的原始变量，会出现错误。虚继承就是为了解决这个问题。

```cpp
    class A;
    class B:virtual public A
    class C:virtual public A
    class D:public B,C
```

&emsp;&emsp;虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。本例中的 A 就是一个**虚基类**。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

&emsp;&emsp;普通继承是按照构造函数出现的顺序依次调用的。对于虚继承来说，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数。


### 4.7 只能在堆/栈上实例化的类

&emsp;&emsp;实例化对象有两种方法。

&emsp;&emsp;静态建立，由编译器自动为对象在栈中分配内存，是直接移动栈顶指针，腾出适当的空间，然后再这片空间上调用构造函数生成对象。  
&emsp;&emsp;这种静态建立是直接调用类的构造函数。   

&emsp;&emsp;动态建立类对象，是使用new运算符将对象建立在堆空间中。  
&emsp;&emsp;这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间（这种方法，间接调用类的构造函数）

#### 4.7.1 只能在栈上(静态对象)

&emsp;&emsp;只有使用new运算符才会在堆上创建对象。重载操作符，将其设为私有即可。

```cpp
class  A  
{  
private :  
    void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的   
    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete   
public :  
    A(){}  
    ~A(){}  
}; 
```

#### 4.7.2 只能在堆上(动态对象)

&emsp;&emsp;私有析构函数。

```cpp
class  A  
{  
protected :  
    A(){}  
    ~A(){}  
public :  
    // 提供实例化的方法
    static  A* create()  
    {  
        return  new  A();  
    }  
    // 当用new建立后，无法delete。因为delete会调用对象的析构函数，但是析构函数在类外无法访问。
    void  destory()  
    {  
        delete  this ;  
    }  
};
```


## 5、其它

### 5.1 new/delete 和 malloc/free

+ new/delete是操作符，malloc/free是函数
+ new/delete不只是分配内存，还会调用构造和析构函数。new可以认为是构造函数+malloc
+ new出来的指针是包含类型信息的，malloc返回 的是void*

&emsp;&emsp;```Dog * p = nullptr; delete p;```删除空指针没有问题。

#### 5.1.1 内存泄露和内存越界

&emsp;&emsp;内存泄露：控件没有释放  
&emsp;&emsp;内存溢出/越界：访问越界 

### 5.2 main函数执行前后发生了什么？

#### 5.2.1 main函数执行前

&emsp;&emsp;设置栈指针；  
&emsp;&emsp;初始化static静态和global全局变量(包括全局对象的初始化)，即data段的内容；  
&emsp;&emsp;给未初始化部分的全局变量赋初值；  
&emsp;&emsp;然后才真正运行main函数；  

#### 5.2.2 main函数执行后

&emsp;&emsp;main函数return后，执行```atexit(func_3);```注册的函数，后注册的先执行

### 5.3 静态转换(static_cast)和动态转换(dynamic_cast)

#### 5.3.1 静态转换

+ 基本数据类型的转换（如将int类型转换为char类型）

+ 用于类层次结构中父类和子类之间指针或引用的转换。（有继承关系的）

  + 上行转换：将子类的指针或引用转换成父类表示，这是安全可行的。
  + 下行转换：但是将父类的指针或引用转换成子类表示时，就是不安全的（如果没有动态类型检查的话）

#### 5.3.2 动态转换

&emsp;&emsp;使用dynamic_cast的好处在于，当想要将父类的指针或引用转换成子类表示时，dynamic_cast具有类型检查的功能，这使其比static_cast更加安全。但不支持基本数据类型转换。

&emsp;&emsp;动态类型转换dynamic_cast经常使用在多态场景下，基类和派生类的相互转换，并且比static_cast更为安全，但效率比较低。而且我们可以通过**判断转换后的指针值是否为NULL**判断是否转换成功。  

&emsp;&emsp;dynamic_cast依赖于RTTI特性。

### 5.4 RTTI

&emsp;&emsp;RTTI的全称是"Run Time Type Identification"，即运行时类型识别。  
&emsp;&emsp;C++中的RTTI机制是通过类型信息对象（Type Information Object）实现的。每个具有多态性的类（包括虚函数或虚基类）都会生成一个类型信息对象，其中包含了有关该类的类型信息，例如类的名称、继承关系、虚函数表等。这些类型信息对象由编译器在编译时生成，并与每个类的对象关联起来。

+ typeid运算符

  typeid 是C++中的一个操作符，用于在**运行时**获取一个表达式的类型信息。

```cpp
Test tt;
const std::type_info& typeInfo = typeid(tt);
std::cout << typeInfo.name() << std::endl;  
// 输出: 4Test
```