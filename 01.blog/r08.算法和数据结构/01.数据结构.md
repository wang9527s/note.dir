## 1、概述

&emsp;&emsp;数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法。

+ 逻辑结构
  + 集合：成员之间没有关系
  + 线性（元素之间都是一对一的关系）：链表、数组
  + 非线性（元素之间存在多对多的关系）：树、图（有向图、无向图、有权图）、散列表

+ 物理结构
  + 顺序
  + 链式
  + 索引：根据确定节点的索引号确定存储地址
  + 散列：根据节点的关键字（Key）的值确定存储地址
  
&emsp;&emsp;索引和散列的区别就是hashmap和普通map的区别；key值是通过一种算法来运算出来的。

### 1.1 数据结构中常用的操作

+ 增
+ 删
+ 改
+ 查
+ 排

## 2、二叉树

+ 满二叉树：节点个数为2的n次方-1，即除最后一行，都有2个子节点。
+ 完全二叉树：最后一行不满的满二叉树

### 2.1 二叉搜索树

&emsp;&emsp;最坏的时间复杂度是O(n)

### 2.2 平衡二叉树

&emsp;&emsp;时间复杂度也为O(log 2 N)

+ 定义

&emsp;&emsp;规则1：每个节点最多只有两个子节点（二叉）  
&emsp;&emsp;规则2：每个节点的值比它的左子树所有的节点大，比它的右子树所有节点小（有序）  
&emsp;&emsp;规则3：每个节点左子树的高度与右子树高度之差的绝对值不超过1

+ 保持平衡

&emsp;&emsp;左旋：左边下降，右边的左子树变为左边的右子树

&emsp;&emsp;左左：右旋解决  
&emsp;&emsp;左右：先左旋再右旋  
&emsp;&emsp;右右：左旋解决  
&emsp;&emsp;右左：先右旋再左旋  

&emsp;&emsp;举例：这种不平衡是3号的**左**孩子节点，新增了一个**左**孩子,我们的方法是**右**旋

#### 2.2.1 平衡二叉树的缺陷

&emsp;&emsp;在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
&emsp;&emsp;红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL

### 2.3 红黑树

#### 2.3.1 定义

+ 根节点是黑色的；
+ 每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据；
+ 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
+ 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

#### 2.3.2 插入操作

&emsp;&emsp;红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。所以有如下3中情况

+ 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
+ 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。
+ 其它情况，会违背红黑树的定义，需要进行调整，调整包含两种基础的操作：左右旋转和改变颜色。

### 2.4 哈希表

&emsp;&emsp;不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。

&emsp;&emsp;但有可能出现冲突（碰撞）的情况，效率会降低。

&emsp;&emsp;key类型必须提供operator==()和hash(key)函数。

+ HashMap

&emsp;&emsp;为了解决hash(key)可能出现重复的问题。在每个位置放一个桶（bucket），桶内存放对应的元素。  
&emsp;&emsp;使用vector存放桶坐标/地址。

&emsp;&emsp;每一个桶都存着链表的 head 节点；当桶的大小超过8，数据结构会有list转为map。
