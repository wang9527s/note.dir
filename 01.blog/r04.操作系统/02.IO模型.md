## IO模型的分类

| 分类 | 特点 | 实现| 
| ------- | ------- | ----|
| 阻塞IO模型| 进程挂起直到操作完成，适用于并发量较小的应用 | 阻塞socket |
| 非阻塞IO模型|非阻塞调用，立即返回结果，适用于一些不需要即时响应的场景	| 非阻塞式 socket |
| IO复用模型	| 适用高并发服务应用开发：一个进程（线程）响应多个请求； | select、poll、epoll |
| 信号驱动IO模型| 进程注册信号处理函数，内核数据就绪时发送信号通知进程 | SIGIO、fcntl |
| 异步IO模型|内核准备好数据后，将数据拷贝到用户空间；然后通知用户态进程|aio_* 系列函数  |


## 阻塞式 I/O（Blocking I/O）：

+ 特点

  - 进程阻塞挂起不消耗CPU资源，及时响应每个操作；
  - 实现难度低、开发应用较容易；
  - 适用并发量小的网络应用开发；

+ 实现：Unix/Linux 的阻塞式文件 I/O。

## 非阻塞式 I/O（Non-blocking I/O）：

&emsp;&emsp;线程在进行 I/O 操作时，不会被阻塞，而是立即返回一个结果，如果数据没有准备好，会返回一个特定的错误码或标志。

+ 特点
  - 进程轮询（重复）调用，消耗CPU的资源；
  - 实现难度低、开发应用相对阻塞IO模式较难；
  - 适用并发量较小、且不需要及时响应的网络应用开发；

## I/O 复用（I/O Multiplexing）：

### select

+ 使用文件描述符集合传递给内核，内核轮询扫描文件描述符集合。
  
  用户态和内核态传递数据，需要拷贝整个描述符集合。用户态收到数据也需要遍历一遍，效率低。

+ 时间复杂度高，每次操作需要遍历整个集合。
  
+ 数量有限制
  select 使用固定长度的 BitsMap，表示文件描述符集合，所支持的文件描述符的个数是有限制的，1024个。

### poll

+ 使用动态数组组织待检测的文件描述符，突破了文件描述符个数限制。
+ 受系统文件描述符限制。

### epoll

&emsp;&emsp;epoll 通过两个方面，很好解决了 select/poll 的问题。

+ *第一点*，epoll 在内核里使用**红黑树**来跟踪进程所有待检测的文件描述字。
  
  把需要监控的socket加入内核中的红黑树里（增删改时间复杂度是 `O(logn)`）。  
  select/poll 每次操作时都传入整个 socket 集合给内核，而只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。

+ *第二点*， epoll 使用**事件驱动**的机制。
  
  内核里维护了一个链表来记录就绪事件，当某个 socket有事件发生时，内核会将其加入到这个就绪事件列表中。  
  当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

## 信号驱动IO模型

&emsp;&emsp;当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

## 异步 I/O（Asynchronous I/O）：

特点：I/O 操作完全由操作系统负责，应用程序只需要发起一个 I/O 请求，然后可以继续执行其他任务，当操作完成后，操作系统会通知应用程序。
实现：在 Unix/Linux 系统中可以使用 aio_* 系列的异步 I/O 函数，例如 aio_read、aio_write 等

