## 1、内存分区模型

### 1.1 C++程序在执行时，将内存大方向划分为4个区域

+ 代码区：存放函数体的二进制代码，由操作系统进行管理的

&emsp;&emsp;存放 CPU 执行的机器指令  
&emsp;&emsp;代码区是**共享的**，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可  
&emsp;&emsp;代码区是**只读的**，使其只读的原因是防止程序意外地修改了它的指令

+ 全局区

&emsp;&emsp;**全局变量和静态变量**存放在此  
&emsp;&emsp;全局区还包含了**常量区, 存放 const修饰的全局常量 和 字符串常量**  
&emsp;&emsp;该区域的数据在程序结束后由操作系统释放

+ 栈区：存**放函数的参数、局部变量、局部常量**

&emsp;&emsp;栈空间由操作系统提供，在编译阶段确定入栈和出栈的操作。

+ 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

&emsp;&emsp;用new开辟的对象（手动释放）

### 1.2 堆栈空间的比较

&emsp;&emsp;栈空间是一块连续的区域，是一个严格后进先出的数据结构，有计算机底层的支持，压栈和出栈都有专门的指令和寄存器，效率较高。

&emsp;&emsp;堆空间逻辑上是连续的，物理上不是连续的（多个malloc之间）。malloc/free操作很容易造成堆碎片

## 2、内存管理

&emsp;&emsp;[内存管理](./03.内存管理.md)

## 3、进程线程协程

### 3.1 概念

&emsp;&emsp;每个线程/协程有**独立的栈空间**。共享全局区和堆区。   

&emsp;&emsp;**协程**可以理解为**用户态线程**。协程间的切换不涉及用户态和内核态的切换。  

&emsp;&emsp;线程本身只占用少量的系统资源，其内存空间也只拥有堆栈区与线程控制块（Thread Control Block，简称TCB），因此对线程的调度需要的系统开销会小得多，能够更高效地提高任务的并发度。

### 3.2 进程

&emsp;&emsp;进程切换就简单的几步：

+ 保存之前运行的进程上下文
+ 调用准备运行的进程的上下文
+ CPU使用权交接

### 3.3 线程

+ 一个进程中的多个线程共享以下资源
 
  - **静态数据（例如全局变量等）**  
  - 打开文件的文件描述符  
  - 信号处理函数  
  - 执行的命令、当前工作目录、用户ID（UID）、用户组ID（GID） 
 
+ 每个线程私有的资源有：  

  - 线程标识符（简称线程号，TID）、程序计数器（PC）与相关寄存器、执行状态与属性、错误号errno、信号掩码与优先级  
  - **堆栈区（局部变量、函数返回地址等）**

## 4、进程调度算法

### 4.1 抢占式

&emsp;&emsp;

### 4.2 先来先服务调度算法

顾名思义，先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

后面的作业等待的时间就会很长。

### 4.3 最短作业优先调度算法

它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。

这显然对长作业不利，很容易造成一种极端现象。  
比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。

### 4.4 时间片轮转调度算法

每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。

如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；
如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

一般来说，时间片设为 20ms~50ms 通常是一个比较合理的折中值。

### 4.5 最高优先级调度算法