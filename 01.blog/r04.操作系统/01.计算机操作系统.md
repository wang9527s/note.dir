## 1、内存分区模型

### 1.1 C++程序在执行时，将内存大方向划分为4个区域

+ 代码区：存放函数体的二进制代码，由操作系统进行管理的

&emsp;&emsp;存放 CPU 执行的机器指令  
&emsp;&emsp;代码区是**共享的**，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可  
&emsp;&emsp;代码区是**只读的**，使其只读的原因是防止程序意外地修改了它的指令

+ 全局区

&emsp;&emsp;**全局变量和静态变量**存放在此  
&emsp;&emsp;全局区还包含了**常量区, 存放 const修饰的全局常量 和 字符串常量**  
&emsp;&emsp;该区域的数据在程序结束后由操作系统释放

+ 栈区：存**放函数的参数、局部变量、局部常量**

&emsp;&emsp;栈空间由操作系统提供，在编译阶段确定入栈和出栈的操作。

+ 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

&emsp;&emsp;用new开辟的对象（手动释放）

### 1.2 堆栈空间的比较

&emsp;&emsp;栈空间是一块连续的区域，是一个严格后进先出的数据结构，有计算机底层的支持，压栈和出栈都有专门的指令和寄存器，效率较高。

&emsp;&emsp;堆空间逻辑上是连续的，物理上不是连续的（多个malloc之间）。malloc/free操作很容易造成堆碎片

## 2、 内存管理

&emsp;&emsp;在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。  
&emsp;&emsp;malloc申请n字节的空间，实际申请到的block空间比n大，其中存放了一些控制块。

### 2.1 虚拟内存

&emsp;&emsp;[一篇文 带你搞懂，虚拟内存、内存分页、分段、段页式内存管理（超详细）](https://blog.csdn.net/m0_52192682/article/details/125781953)

+ 页表切换

  首先，每个进程都有自己的虚拟地址和物理地址的映射关系表，存放在内核态的某个区域。

  在进程切换的时候，操作系统会更改CPU中的页表基址寄存器，以指向新进程的页表。这个页表映射了新进程的虚拟地址空间到物理内存地址的关系。  
  可参考[TLB页表失效](https://www.eet-china.com/mp/a98376.html)。 

+ 换页和缺页异常

  - 换页操作
    
    换页操作通常是指操作系统为了管理内存资源，将某些内存页保存到磁盘上的一个过程。  
    当系统需要更多的物理内存来满足其他程序的需求时，将不再使用或很少使用的内存页保存到磁盘上，在需要时再从磁盘读取回来。

  - 缺页异常
  
    缺页异常是指当程序试图访问一个已经被映射到虚拟地址空间中，但实际上并没有加载到物理内存中的页时，会触发的一种异常。  
    这时，操作系统会通过预先设置好的缺页异常处理函数来处理这种情况。  
    查找空闲的物理页、将缺失的页从磁盘交换区（swap space）加载到物理内存中，并更新页表以映射虚拟地址到新加载的物理页。  
    这个过程可能涉及到复杂的数据结构和算法，以确保高效地管理内存资源。

&emsp;&emsp;换页操作和缺页异常，都是虚拟内存的调度策略。  
&emsp;&emsp;在操作系统运行的过程中，时有发生（包括进程切换）。


## 3、进程线程协程

### 3.1 概念

&emsp;&emsp;每个线程/协程有**独立的栈空间**。共享全局区和堆区。   

&emsp;&emsp;**协程**可以理解为**用户态线程**。协程间的切换不涉及用户态和内核态的切换。  

&emsp;&emsp;线程本身只占用少量的系统资源，其内存空间也只拥有堆栈区与线程控制块（Thread Control Block，简称TCB），因此对线程的调度需要的系统开销会小得多，能够更高效地提高任务的并发度。

### 3.2 进程

&emsp;&emsp;进程切换就简单的几步：

+ 保存之前运行的进程上下文
+ 调用准备运行的进程的上下文
+ CPU使用权交接

### 3.3 线程

+ 一个进程中的多个线程共享以下资源
 
  - **静态数据（例如全局变量等）**  
  - 打开文件的文件描述符  
  - 信号处理函数  
  - 执行的命令、当前工作目录、用户ID（UID）、用户组ID（GID） 
 
+ 每个线程私有的资源有：  

  - 线程标识符（简称线程号，TID）、程序计数器（PC）与相关寄存器、执行状态与属性、错误号errno、信号掩码与优先级  
  - **堆栈区（局部变量、函数返回地址等）**

## 4、进程调度算法

### 4.1 抢占式

&emsp;&emsp;

### 4.2 先来先服务调度算法

顾名思义，先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

后面的作业等待的时间就会很长。

### 4.3 最短作业优先调度算法

它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。

这显然对长作业不利，很容易造成一种极端现象。  
比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。

### 4.4 时间片轮转调度算法

每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。

如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；
如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

一般来说，时间片设为 20ms~50ms 通常是一个比较合理的折中值。

### 4.5 最高优先级调度算法